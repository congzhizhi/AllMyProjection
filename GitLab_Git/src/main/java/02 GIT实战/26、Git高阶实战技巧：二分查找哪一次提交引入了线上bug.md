
这是一个非常实用的技巧773692218

 

我可以给大家介绍一下，我们在项目中是如何去使用的

 

经常可能会出现说，线上有bug，然后排查bug的时候，最终会定位到是哪个类的哪几行代码造成的这个bug，此时就需要去看到底是哪一次提交，谁，对这几行代码的修改造成了这次线上bug，需要去定位责任人，发生时间

 

如果是比较严重的case，不是bug，case是什么？case你可以理解为是，bug引发的血案，比如说导致用户无法支付，给公司造成了500万的经济损失，肯定是要追查谁是责任人的

 

就是说，如果你们线上发现了bug，然后定位到bug是某个代码文件的某几行代码导致的，此时需要看一下是谁在哪一次commit引入了这几行导致bug的代码

 

谁在哪一次commit具体的引入了这个bug，用git提供的二分查找

 

git bisect start：开始二分查找

git bisect bad：标注当前这个commit是有bug的

git biset good v1.0.0：用tag来标注说从上一次哪个上线为止，是没有bug的，就是那个tag对应的commit之前都是好的

 

此时git会做一个二分查找，比如说两次commit中间差了12个commit，此时会给你定位到第6个commit

 

然后你可以对这个版本的代码，运行个测试用例，看看bug能否复现出来

 

如果发现这个版本的代码没有bug，那么说明是之后引入的bug，输入git bisect good，会继续往后面二分查找；如果这个版本就有bug，那么说明是之前引入的bug，输入git bisect bad，会继续往前二分查找

 

以此类推，直到最后找到最后一个commit，认为就是这个commit开始引入的bug

 

git会自动推断出来是哪个commit是实际引入bug的commit，最后会给你打印出来

 

最后你需要执行git bisect reset，就是从二分查找状态中恢复到之前的状态

 

 

 

 

 

 